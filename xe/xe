#!/bin/bash

# xe - Modular Web Development Script for macOS
# Supports bun, pnpm, and npm package managers

set -e  # Exit on any error

# Global variables
PACKAGE_MANAGER=""
FRONTEND_FLAG=false
BACKEND_FLAG=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper function for colored output
echo_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Display usage information
usage() {
    echo_color "$BLUE" "xe - Modular Web Development Script"
    echo ""
    echo "Usage: xe [command] [options]"
    echo ""
    echo "Commands:"
    echo "  install, i     Install dependencies or specific packages"
    echo "  dev            Start development server"
    echo "  dev init       Full project initialization (install + prisma + dev)"
    echo "  build          Build the project"
    echo "  lint           Run linting"
    echo "  prisma         Run Prisma commands (generate, db push, db pull)"
    echo "  shadcn         Manage shadcn/ui components"
    echo ""
    echo "Options:"
    echo "  -f             Frontend mode (default)"
    echo "  -b             Backend mode"
    echo ""
    echo "Examples:"
    echo "  xe install           Install all dependencies"
    echo "  xe install axios     Install specific package"
    echo "  xe i react typescript   Install multiple packages"
    echo "  xe i -D nodemon      Install dev dependencies"
    echo "  xe dev               Start dev server"
    echo "  xe dev init          Full project initialization"
    echo "  xe prisma migrate dev --name my_migration"
    echo "  xe shadcn add button --overwrite"
}

# Detect package manager based on lock files
detect_package_manager() {
    # Check current directory first
    if [[ -f "bun.lock" ]]; then
        PACKAGE_MANAGER="bun"
    elif [[ -f "pnpm-lock.yaml" ]]; then
        PACKAGE_MANAGER="pnpm"
    elif [[ -f "package-lock.json" ]]; then
        PACKAGE_MANAGER="npm"
    elif [[ -f "package.json" ]]; then
        # package.json exists but no lock file - prompt user
        echo_color "$YELLOW" "‚ö†Ô∏è  No lock file found. Please select package manager:"
        echo "1) bun"
        echo "2) pnpm"
        echo "3) npm"
        read -r choice
        case $choice in
            1) PACKAGE_MANAGER="bun" ;;
            2) PACKAGE_MANAGER="pnpm" ;;
            3) PACKAGE_MANAGER="npm" ;;
            *) PACKAGE_MANAGER="npm" ;;
        esac
    else
        # No package.json in current directory, check client folder
        if [[ -f "client/package.json" ]]; then
            echo_color "$BLUE" "üìÅ Found package.json in client/ directory. Switching to client/"
            cd client
            detect_package_manager
            return
        else
            echo_color "$RED" "‚ùå No package.json found in current directory or client/ subdirectory."
            exit 1
        fi
    fi
    
    echo_color "$GREEN" "üì¶ Detected package manager: $PACKAGE_MANAGER"
}

# Check if node_modules exists
check_node_modules() {
    if [[ ! -d "node_modules" ]]; then
        echo_color "$YELLOW" "‚ö†Ô∏è  node_modules not found. Run xe install? (y/n)"
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            run_install
        else
            echo_color "$RED" "‚ùå Exiting without installing dependencies."
            exit 1
        fi
    fi
}

# Install dependencies or specific packages
run_install() {
    detect_package_manager
    
    # Get all arguments after the install command
    shift  # Remove 'install' or 'i' from arguments
    local args=("$@")
    
    if [[ ${#args[@]} -eq 0 ]]; then
        # No arguments specified - install all dependencies
        echo_color "$BLUE" "üîß Installing all dependencies with $PACKAGE_MANAGER..."
        
        case $PACKAGE_MANAGER in
            bun)
                bun install
                ;;
            pnpm)
                pnpm install
                ;;
            npm)
                npm install
                ;;
        esac
        
        echo_color "$GREEN" "‚úÖ Dependencies installed successfully!"
    else
        # Pass all arguments directly to the package manager
        echo_color "$BLUE" "üì¶ Running: $PACKAGE_MANAGER install ${args[*]}"
        
        case $PACKAGE_MANAGER in
            bun)
                bun install "${args[@]}"
                ;;
            pnpm)
                pnpm install "${args[@]}"
                ;;
            npm)
                npm install "${args[@]}"
                ;;
        esac
        
        echo_color "$GREEN" "‚úÖ Installation completed!"
    fi
}

# Start development server
run_dev() {
    detect_package_manager
    
    # Get all arguments after the dev command
    shift  # Remove 'dev' from arguments
    local args=("$@")
    
    # Handle dev subcommands
    if [[ "${args[0]}" == "init" ]]; then
        echo_color "$BLUE" "üöÄ Running full project initialization..."
        
        # Step 1: Install dependencies
        echo_color "$BLUE" "üì¶ Step 1: Installing dependencies..."
        run_install install
        
        # Step 2: Run Prisma commands (if schema exists)
        if command -v prisma &> /dev/null || [[ -f "prisma/schema.prisma" ]]; then
            echo_color "$BLUE" "üóÉÔ∏è  Step 2: Setting up Prisma..."
            run_prisma prisma
        else
            echo_color "$YELLOW" "‚ö†Ô∏è  Skipping Prisma setup (no schema found)"
        fi
        
        # Step 3: Start dev server
        echo_color "$BLUE" "üåê Step 3: Starting development server..."
        # Remove 'init' from args for the actual dev command
        unset 'args[0]'
    else
        # Regular dev command - check for node_modules first
        check_node_modules
        echo_color "$BLUE" "üåê Starting development server with $PACKAGE_MANAGER..."
    fi
    
    case $PACKAGE_MANAGER in
        bun)
            bun dev "${args[@]}"
            ;;
        pnpm)
            pnpm dev "${args[@]}"
            ;;
        npm)
            npm run dev "${args[@]}"
            ;;
    esac
}

# Build the project
run_build() {
    detect_package_manager
    
    # Get all arguments after the build command
    shift  # Remove 'build' from arguments
    local args=("$@")
    
    echo_color "$BLUE" "üî® Building project with $PACKAGE_MANAGER..."
    
    case $PACKAGE_MANAGER in
        bun)
            bun run build "${args[@]}"
            ;;
        pnpm)
            pnpm run build "${args[@]}"
            ;;
        npm)
            npm run build "${args[@]}"
            ;;
    esac
    
    echo_color "$GREEN" "‚úÖ Build completed successfully!"
}

# Run linting
run_lint() {
    detect_package_manager
    
    # Get all arguments after the lint command
    shift  # Remove 'lint' from arguments
    local args=("$@")
    
    echo_color "$BLUE" "üßπ Running lint with $PACKAGE_MANAGER..."
    
    case $PACKAGE_MANAGER in
        bun)
            bun lint "${args[@]}"
            ;;
        pnpm)
            pnpm lint "${args[@]}"
            ;;
        npm)
            npm run lint "${args[@]}"
            ;;
    esac
    
    echo_color "$GREEN" "‚úÖ Linting completed!"
}

# Run Prisma commands
run_prisma() {
    detect_package_manager
    
    # Get all arguments after the prisma command
    shift  # Remove 'prisma' from arguments
    local args=("$@")
    
    # If no arguments provided, run default commands
    if [[ ${#args[@]} -eq 0 ]]; then
        echo_color "$BLUE" "üóÉÔ∏è  Running default Prisma commands with $PACKAGE_MANAGER..."
        
        case $PACKAGE_MANAGER in
            bun)
                echo_color "$BLUE" "üìã Generating Prisma client..."
                bun prisma generate
                echo_color "$BLUE" "üì§ Pushing database changes..."
                bun prisma db push
                echo_color "$BLUE" "üì• Pulling database schema..."
                bun prisma db pull
                ;;
            pnpm)
                echo_color "$BLUE" "üìã Generating Prisma client..."
                pnpm prisma generate
                echo_color "$BLUE" "üì§ Pushing database changes..."
                pnpm prisma db push
                echo_color "$BLUE" "üì• Pulling database schema..."
                pnpm prisma db pull
                ;;
            npm)
                echo_color "$BLUE" "üìã Generating Prisma client..."
                npx prisma generate
                echo_color "$BLUE" "üì§ Pushing database changes..."
                npx prisma db push
                echo_color "$BLUE" "üì• Pulling database schema..."
                npx prisma db pull
                ;;
        esac
    else
        # Pass all arguments to prisma
        echo_color "$BLUE" "üóÉÔ∏è  Running: prisma ${args[*]}"
        
        case $PACKAGE_MANAGER in
            bun)
                bun prisma "${args[@]}"
                ;;
            pnpm)
                pnpm prisma "${args[@]}"
                ;;
            npm)
                npx prisma "${args[@]}"
                ;;
        esac
    fi
    
    echo_color "$GREEN" "‚úÖ Prisma commands completed!"
}

# Manage shadcn/ui components
run_shadcn() {
    detect_package_manager
    
    # Get all arguments after the shadcn command
    shift  # Remove 'shadcn' from arguments
    local args=("$@")
    
    if [[ ${#args[@]} -eq 0 ]]; then
        echo_color "$RED" "‚ùå Invalid shadcn command. Use 'xe shadcn init' or 'xe shadcn add <component> [options]'"
        exit 1
    fi
    
    echo_color "$BLUE" "üé® Running: shadcn ${args[*]}"
    
    case $PACKAGE_MANAGER in
        bun)
            bunx --bun shadcn@latest "${args[@]}"
            ;;
        pnpm)
            pnpm dlx shadcn@latest "${args[@]}"
            ;;
        npm)
            npx shadcn@latest "${args[@]}"
            ;;
    esac
    
    echo_color "$GREEN" "‚úÖ shadcn/ui command completed!"
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--frontend)
                FRONTEND_FLAG=true
                shift
                ;;
            -b|--backend)
                BACKEND_FLAG=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Don't set default flags - let commands handle their own logic
}

# Main function
main() {
    # Parse flags first
    parse_args "$@"
    
    # Get remaining arguments after flag parsing
    local remaining_args=()
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--frontend|-b|--backend)
                shift
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Set positional parameters to remaining arguments
    set -- "${remaining_args[@]}"
    
    local command=$1
    
    # If no command provided, show usage
    if [[ -z "$command" ]]; then
        usage
        exit 1
    fi
    
    # Execute the appropriate command
    case $command in
        install|i)
            run_install "$@"
            ;;
        dev)
            run_dev "$@"
            ;;
        build)
            run_build "$@"
            ;;
        lint)
            run_lint "$@"
            ;;
        prisma)
            run_prisma "$@"
            ;;
        shadcn)
            run_shadcn "$@"
            ;;
        *)
            echo_color "$RED" "‚ùå Unknown command: $command"
            echo ""
            usage
            exit 1
            ;;
    esac
}

# Error handling
trap 'echo_color "$RED" "‚ùå An error occurred. Exiting."; exit 1' ERR

# Run main function with all arguments
main "$@"